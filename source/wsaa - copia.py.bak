# Author: Gerardo Fisanotti - DvSHyS/DiOPIN/AFIP - 13-apr-07
# Function: Get an authorization ticket (TA) from AFIP WSAA
# Input:
#        WSDL, CERT, PRIVATEKEY, PASSPHRASE, SERVICE, URL
#        Check below for its definitions
# Output:
#        TA.xml: the authorization ticket as granted by WSAA.
#==============================================================================
import datetime
import os
import sys
import time

from lxml import etree

from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.primitives.serialization.pkcs7 import PKCS7Options
from cryptography.hazmat.primitives.serialization.pkcs7 import PKCS7SignatureBuilder
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.x509 import load_pem_x509_certificate
import base64
from zeep import Client
from zeep.transports import Transport
from zeep.exceptions import Fault

from requests import Session

###################################
# Constantes: definición
###################################
WSDL = "docs/wsaa.wsdl"
CERT = "certificados/certificado_x509.pem"
CLAVEPRIVADA = "certificados/claveprivada.pk"
PASSPHRASE = None  # Sin passphrase is needed si la clave privada no está encriptada
PROXY_HOST = "10.1.1.10"
PROXY_PORT = 51966
URL_TESTING_LOGIN = "https://wsaahomo.afip.gov.ar/ws/services/LoginCms"
URL_PRODUCCION_LOGIN = "https://wsaa.afip.gov.ar/ws/services/LoginCms"
SERVICIO = "ws_sr_padron_a4"
ARCHIVO_XML_CMS = "docs/LoginTicketRequest.xml.cms"
###################################

#########################################################################################################
# Flujo Principal
# A continuación se describen los pasos que se deberán seguir para solicitar un TA al WSAA.
# Cada uno de los puntos es explicado detalladamente en los apartados siguientes.
# 1. Generar el mensaje del TRA (LoginTicketRequest.xml)
# 2. Generar un CMS que contenga el TRA, su firma electrónica y el certificado
# X.509 (LoginTicketRequest.xml.cms)
# 3. Codificar en Base64 el CMS (LoginTicketRequest.xml.cms.bse64)
# 4. Invocar WSAA con el CMS y recibir LoginTicketResponse.xml
# 5. Extraer y validar la información de autorización (TA).
#########################################################################################################


def call_wsaa(request):

    # Configurar el proxy
    session = Session()
    session.proxies = {
        'http': f'http://{PROXY_HOST}:{PROXY_PORT}',
        'https': f'http://{PROXY_HOST}:{PROXY_PORT}',
    }

    # Crear el cliente SOAP
    client = Client(WSDL, transport=Transport(session=session))

    try:
        # Llamar al método loginCms del servicio
        result = client.service.loginCms(in0=request)

        # Guardar las solicitudes y respuestas SOAP en archivos
        with open("request-loginCms.xml", "w") as request_file:
            request_file.write(str(client.transport.last_sent))

        with open("response-loginCms.xml", "w") as response_file:
            response_file.write(str(client.transport.last_received))

        return result

    except Fault as fault:
        print(f"SOAP Fault: {fault.code}\n{fault.message}\n")
        return None


def obtener_o_crear_tra(servicio, hoy, tra):

    hoy_iso = (hoy - datetime.timedelta(seconds=60)).isoformat()
    maniana = hoy + + datetime.timedelta(days=1)
    maniana_iso = (maniana - datetime.timedelta(seconds=60)).isoformat()

    root = etree.Element('loginTicketRequest', version='1.0')
    header = etree.SubElement(root, 'header')
    etree.SubElement(header, 'uniqueId').text = str(int(time.time()))

    etree.SubElement(header, 'generationTime').text = hoy_iso
    etree.SubElement(header, 'expirationTime').text = maniana_iso

    etree.SubElement(root, 'service').text = servicio
    tree = etree.ElementTree(root)
    tree.write(tra, xml_declaration=True, encoding='UTF-8', pretty_print=True)


# def cargar_tra(xml_file):
#     with open(xml_file, 'rb') as f:
#         return f.read()


# def firmar_tra(data, key_file, passphrase):
#     key = serialization.load_pem_private_key(
#         open(key_file, 'rb').read(),
#         password=passphrase,
#         backend=default_backend()
#     )
#     signature = key.sign(
#         data,
#         padding.PKCS1v15(),
#         hashes.SHA256()
#     )
#     return signature

# def sign_message(xml_login_ticket_request, ruta_del_certificado_firmante, ruta_clave_privada, password, verbose_mode):
#     if verbose_mode:
#         print(f"***Leyendo certificado: {ruta_del_certificado_firmante}")
#
#     with open(xml_login_ticket_request, "r") as xml_login_file:
#         xml_login_data = xml_login_file.read()
#
#     with open(ruta_del_certificado_firmante, "rb") as cert_file:
#         cert_data = cert_file.read()
#
#     with open(ruta_clave_privada, "rb") as pk_file:
#         pk_data = pk_file.read()
#
#     cert_firmante = load_pem_x509_certificate(cert_data)
#     private_key = serialization.load_pem_private_key(pk_data, password=password)
#
#     if verbose_mode:
#         print("***Firmando: ")
#         print(xml_login_ticket_request)
#
#     # Convert the login ticket request to bytes
#     msg_bytes = xml_login_data.encode('utf-8')
#
#     # Sign the message
#     signature = private_key.sign(
#         msg_bytes,
#         padding.PKCS1v15(),
#         hashes.SHA256()
#     )
#
#     # Combine the original message and the signature
#     # signed_data = xml_login_data.encode('utf-8') + signature
#
#     return signature

# def obtener_certificado(cert_file):
#     cert_pem = open(cert_file, 'rb').read()
#     return load_pem_x509_certificate(cert_pem, default_backend())

# def codificar_base64(cms_encoded):
#     # Leer el contenido del archivo
#     # with open(archivo_xml_cms, "rb") as f:
#     #     cms_data_leido = f.read()
#
#     return base64.b64encode(cms_encoded)

# def generar_tra(tra_hoy):
#     # Pasos
#     tra_data = cargar_tra(tra_hoy)
#     # firma = firmar_tra(tra_data, CLAVEPRIVADA, PASSPHRASE)
#     certificado = obtener_certificado(CERT)
#     cms_data = crear_cms(tra_data, firma, certificado)
#
#     # con cms_data se genera el archivo "LoginTicketRequest.xml.cms"
#     # archivo_xml_cms = "docs/LoginTicketRequest.xml.cms"
#     f = open(ARCHIVO_XML_CMS, "wb")
#     f.write(cms_data)
#     f.close()
def create_embeded_pkcs7_signature(tra_hoy: str, cert: bytes, key: bytes) -> bytes:
    # def create_embeded_pkcs7_signature(data: bytes, cert: bytes, key: bytes) -> bytes:
    """Creates an embedded ("nodetached") PKCS7 signature.

    This is equivalent to the output of::

        openssl smime -sign -signer cert -inkey key -outform DER -nodetach < data
    """

    with open(tra_hoy, "r") as xml_login_file:
        xml_login_data = xml_login_file.read()

    # Convert the XML data to bytes using encode() method
    xml_login_bytes_data = xml_login_data.encode('utf-8')

    with open(cert, "rb") as cert_file:
        cert_data = cert_file.read()

    with open(key, "rb") as pk_file:
        pk_data = pk_file.read()

    try:
        pkey = load_pem_private_key(pk_data, None)
        signcert = load_pem_x509_certificate(cert_data)
    except Exception as e:
        print(f"{e}")
        return None

    return (
        PKCS7SignatureBuilder()
        .set_data(xml_login_bytes_data)
        .add_signer(signcert, pkey, hashes.SHA256())
        .sign(Encoding.DER, [PKCS7Options.Binary])
    )

# @lru_cache(maxsize=1)
# def get_or_create_transport() -> Transport:
#     """Create a specially-configured Zeep transport.
#
#     This transport does two non-default things:
#     - Reduces TLS security. Sadly, AFIP only has insecure endpoints, so we're
#       forced to reduce security to talk to them.
#     - Cache the WSDL file for a whole day.
#
#     This function will only create a transport once, and return the same
#     transport in subsequent calls.
#     """
#
#     session = Session()
#
#     # For each WSDL, extract the domain, and add it as an exception:
#     for environment in WSDLS.values():
#         for url in environment.values():
#             parsed = urlparse(url)
#             base_url = f"{parsed.scheme}://{parsed.netloc}"
#             session.mount(base_url, AFIPAdapter())
#
#     return Transport(cache=SqliteCache(timeout=86400), session=session)


def main():

    if not os.path.exists(CERT):
        print(f"Failed to open {CERT}")
        sys.exit(1)

    if not os.path.exists(CLAVEPRIVADA):
        print(f"Failed to open {CLAVEPRIVADA}")
        sys.exit(1)

    if not os.path.exists(WSDL):
        print(f"Failed to open {WSDL}")
        sys.exit(1)

    # if len(sys.argv) < 2:
    #     show_usage(sys.argv[0])
    #     sys.exit(1)

    # service = sys.argv[1]

    # Verifico si existe el tra.xml del día de hoy, si no existe lo genero
    # para reutilizarlo ya que tiene una duración de un día entre generación y expiración
    hoy_str = datetime.datetime.today().strftime("%Y-%m-%d")
    tra_hoy = f"docs/{hoy_str}-tra.xml"
    if not os.path.exists(tra_hoy):
        obtener_o_crear_tra(SERVICIO, datetime.datetime.today(), tra_hoy)

    cms_signed_data = create_embeded_pkcs7_signature(tra_hoy, CERT, CLAVEPRIVADA)
    request = base64.b64encode(cms_signed_data).decode()

    ticket_de_acceso = call_wsaa(request)
    print(ticket_de_acceso)


if __name__ == "__main__":
    main()
